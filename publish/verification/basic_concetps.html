<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>basic_concetps</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
<h1 id="verification-basic-concepts">Verification Basic Concepts</h1>
<h2 id="introduction">Introduction</h2>
<p>The ASIC (Application-Specific Integrated Circuit) Design Flow
consists of several steps including: design specification, design entry,
design synthesis, design verification, physical design and design
sing-off. Design Verification typically referens to pre-silicon effort
of fcuntional validation of design using simulation tools.</p>
<p>Digital design verification is the process of testing and validating
the correctness and functionality of a digital design before it is
released or deployed. The goal is to identify and eliminate any design
errors or bugs, and to ensure thtat syustem performs as expected under
different conditions and use cases.</p>
<p><strong>Importance of design verification</strong></p>
<ul>
<li>Increasing design complexity: As the complexity of the design
increases, the number of possible scenarios that need to be verified
also increases.</li>
<li>Iterative process: Design verification is an iterative process that
involves running simulations, analyzing results, and fixing design
errors. This process may need to be repeated multiple times until the
design meets all the required specifications and performs as
expected.</li>
<li>Development of verification environment: The verification
environment must be comprehensive and cover all possible scenarios,
which can be a time-consuming task.</li>
<li>Time-sensitive nature of design verification: Design verification is
a time-sensitive task because it must be completed before the design is
fabricated.</li>
</ul>
<p><strong>What happen if a bug is missed?</strong></p>
<ul>
<li>Rework and delay</li>
<li>Lost revenue</li>
<li>Product recalls</li>
<li>Legal liabilities</li>
</ul>
<p><strong>When is time to stop verification?</strong></p>
<ul>
<li>Achieving code coverage goals: all code coverage goals like branch,
statement, expression, toggle and FSM have been met.</li>
<li>Achieving functional coverage goals: functional coverage is at an
acceptable level.</li>
<li>Meeting performance goals: design meets all performance goals, such
as timing constraints and power consumption requirements.</li>
<li>Finding and fixing critical bugs: no new critical bugs have been
introduced for a certain period</li>
<li>Available reosurces: verification can be stopped if the available
resources are not sufficient to continue, such as budget or time
constraints.</li>
</ul>
<h2 id="verification-techniques">Verification Techniques</h2>
<ul>
<li><strong>Functional Simulation</strong>: it involves running the
digital design on a computer or a simulator to validate its
functionality. The simulation environment may include various inputs,
such as test vectors to ensure design behaves as expected. <em>Example:
testing an ALU.</em></li>
<li><strong>Formal Verification</strong>: involves using mathematical
proofs to verify the correctness of the design. This technique is often
used for critical designs, such as those used in safety-critical
systems. <em>Example: testing that a FIFO never overflows.</em></li>
<li><strong>Emulation</strong>: it involves testing the digital design
on specializrd hardware that can emulate the behaviour of the system.
This technique is often used for large, complex designs that cannot be
simulated on a computer. <em>Example: executing in Linux a Risc-V
processor before manufacturing the chip.</em></li>
<li><strong>Prototyping</strong>: involves building a physical prototype
of the system to test its functionality in a real-world enviroment. This
technique is often used for designs that require testing with real-world
inputs and conditions. <em>Example: test an PCIe interface using an FPGA
before manufacturing the chip.</em></li>
</ul>
<h2 id="verification-methodologies">Verification Methodologies</h2>
<ul>
<li><strong>UVM (Universal Verification Methodology)</strong>:
<ul>
<li>UVM is a widely-used, standardized verification methodology built on
SystemVerilog. It provides a robust framework for functional
verification, offering reusable components for stimulus generation,
checking, and reporting.</li>
<li>Key aspects:
<ul>
<li>Testbenches: The environment where your design gets tested.</li>
<li>Transactions: Defined data packets that are sent across
interfaces.</li>
<li>Sequences: A series of transactions or commands that are run during
verification.</li>
</ul></li>
</ul></li>
<li><strong>Coverage-Driven Verification (CDV)</strong>:
<ul>
<li>This approach focuses on ensuring that all parts of the design are
tested through a combination of code coverage and functional
coverage.</li>
<li>It ensures that all the design’s possible scenarios (including
corner cases) are covered during simulation.</li>
<li><em>Example:</em> Using functional coverage to verify that all
possible states in a finite state machine (FSM) are visited during the
simulation.</li>
</ul></li>
</ul>
<h2 id="key-terms">Key Terms</h2>
<ul>
<li><strong>Code Coverage</strong>: code coverage tools monitor and
report on which parts of the code were exercised during simulation.
Achieving high code coverage is important to ensure all paths and
conditions in the design are tested.
<ul>
<li>Types of code coverage:
<ul>
<li>Statement Coverage: Ensures that every line of code has been
executed.</li>
<li>Branch Coverage: Ensures every decision point (like if statements)
has been both true and false.</li>
<li>Toggle Coverage: Ensures that every flip-flop has been toggled
(set/reset).</li>
</ul></li>
</ul></li>
<li><strong>Functional Coverage</strong>: functional coverage tracks how
well the design’s functionality has been verified. It involves defining
coverage points that represent important design states or events.
<em>Example:</em> Ensuring all address ranges of a memory controller are
tested by creating specific coverage points for them.</li>
<li><strong>Assertions</strong>: are crucial in formal and functional
verification. They help to monitor whether specific conditions hold true
during the simulation and flag errors when these conditions are
violated. <em>Example:</em> A covergroup assertion can be used to ensure
that every possible value of a signal is observed during testing.</li>
</ul>
</body>
</html>
