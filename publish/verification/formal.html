<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>formal</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../styles.css" />
</head>
<body>
<h1 id="formal-verification">Formal Verification</h1>
<p>Formal verification is a method of verifying the correctness of a
digital design through mathematical techniques, rather than relying on
simulation with test cases. It provides a rigorous approach to ensure
that a design adheres to its specifications by proving that the design
is free from errors. This technique is especially useful in designs
where failure can have severe consequences, such as in safety-critical
systems or high-reliability applications.</p>
<p><strong>Why use Formal Verification?</strong></p>
<ul>
<li>High Confidence in Design: it proves that the design will behave as
expected for all possible input conditions. This is particularly
valuable in scenarios where exhaustive simulation is impractical due to
the sheer number of test cases that would be needed.</li>
<li>Critical systems: For designs such as aerospace or medical devices,
where a bug can lead to catastrophic failures, formal verification
ensures that the design meets its functional specifications without the
risk of untested corner cases.</li>
<li>Completeness: Unlike simulation-based approaches, which are limited
by the number of test cases run, formal verification can provide
complete assurance that a property holds across all possible input
conditions.</li>
</ul>
<p><strong>How it works?</strong></p>
<p>Formal verification tools use mathematical models to explore all
possible states of a digital design. These tools typically rely on
techniques such as model checking and theorem proving to exhaustively
verify that a set of properties holds for the design. The properties
could range from simple assertions to more complex temporal properties
that describe the behavior of the system over time.</p>
<p>The verification tool uses the design description (usually written in
HDL) and a set of properties or assertions (often written in
SystemVerilog Assertions, SVA) to prove that the design satisfies the
requirements. If a violation of any property is found, the tool provides
a counterexample that shows the specific sequence of events that led to
the failure.</p>
<h2 id="formal-verification-vs.-assertion-based-verification">Formal
Verification vs.Â Assertion-Based Verification</h2>
<p>Assertion-based verification is a technique that uses assertions
-specifics statements- to check that certain conditions hold during the
verification process. Assertions are typicallly used to express
propierties or expected behaviours of the design.</p>
<p>An assertion in this context is a statement that must always hold
true in the design. If the assertion is violated (i.e., if the condition
it checks is false), the simulator or formal verification tool will
raise an error or failure message, helping the engineer identify
potential issues in the design.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>property fifo_not_overflow<span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">@(</span><span class="kw">posedge</span> clk<span class="op">)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">disable</span> iff <span class="op">(</span>reset<span class="op">)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span>write_enable <span class="op">&amp;&amp;</span> <span class="op">!</span>full<span class="op">)</span> <span class="op">|-&gt;</span> <span class="op">(</span>fifo_count <span class="op">&lt;</span> FIFO_DEPTH<span class="op">);</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>endproperty</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>assert property <span class="op">(</span>fifo_not_overflow<span class="op">)</span> <span class="kw">else</span> <span class="dt">$fatal</span><span class="op">(</span><span class="st">&quot;FIFO overflow detected!&quot;</span><span class="op">);</span></span></code></pre></div>
<p><strong>How are they related?</strong></p>
<p>Assertion-based verification is a methodoly used withing noth formal
verification and simulation to specify and check the behaviour of the
design. It provdies a way to express desired design propierties in a
clear, checkeable form that can be verified during either simulation or
formal verification.</p>
<p>In formal verification, assertions serve as the properties that the
formal tool checks exhaustively across all possible states of the system
to verify that they hold true for every scenario. In simulation-based
verification, assertions are used to monitor the design during
simulation to check whether the design is behaving as expected for a
given set of inputs.</p>
<p><strong>Why are they not the same?</strong></p>
<ul>
<li><p>Scope of check: while formal verification can exhaustively check
the design for all possible input combination and corner cases using
mathematical proofs guaranteeing that a propierty holds in very
scenario, assertion-based verification involves writing individual
assertions to check certain propierties and they need to be written for
each individual case the designer cares about, meaning they are
typically targeted at jey functional behaviours.</p></li>
<li><p>Method of analysis: formal verification use mathematical methods
while assertion-based relies on runtime checks, acting like automated
checks embedded in the design.</p></li>
<li><p>Completeness: formal verification can prove a propierty is true
for all possible cases while assertions-based is limited to the
propierties that the designer has written assertions for.</p></li>
</ul>
</body>
</html>
